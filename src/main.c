#include <pico/stdlib.h>
#include <pico/rand.h>
#include <stdio.h>
#include <tusb.h>

#include "basilisk/display.h"
#include "basilisk/hardware/at28c64b.h"


void display_shell(display* disp);
void eeprom_test(eeprom* prom);
void full_test(eeprom* prom, display* disp);




int main() {
    stdio_init_all();
    gpio_init(25);
    gpio_set_dir(25, GPIO_OUT);

    // wait for serial connection
    while (!tud_cdc_connected()) {
        gpio_put(25, 1);
        sleep_ms(250);
        gpio_put(25, 0);
        sleep_ms(250);
    }
    // clear serial terminal
    sleep_ms(500);
    printf("\x1b");
    printf("[2J");

    // turn on on-board LED
    gpio_put(25, 1);

    // create eeprom struct and init
    eeprom prom;
    eeprom_init(&prom,
        0x000000FF,     // data bus on GPIO[0:7]
        0x001FFF00,     // addr bus on GPIO[8:20]
        26, 22, 21
    );

    // create display struct and init
    display disp;
    display_init(&disp);

    // run full test
    full_test(&prom, &disp);

    // turn off on-bard LED
    gpio_put(25, 0);

    return 0;
}




void display_shell(display* disp) {
    char dbuf[2];
    uint16_t mdata, ldata;
    while (true) {
        dbuf[1] = getchar();
        display_write(disp, 0x1c1c);
        dbuf[0] = getchar();
        switch (dbuf[0]) {
            case '0':
                ldata = BSLK_DISPL_0;
                break;
            case '1':
                ldata = BSLK_DISPL_1;
                break;
            case '2':
                ldata = BSLK_DISPL_2;
                break;
            case '3':
                ldata = BSLK_DISPL_3;
                break;
            case '4':
                ldata = BSLK_DISPL_4;
                break;
            case '5':
                ldata = BSLK_DISPL_5;
                break;
            case '6':
                ldata = BSLK_DISPL_6;
                break;
            case '7':
                ldata = BSLK_DISPL_7;
                break;
            case '8':
                ldata = BSLK_DISPL_8;
                break;
            case '9':
                ldata = BSLK_DISPL_9;
                break;
            case 'a':
                ldata = BSLK_DISPL_A;
                break;
            case 'b':
                ldata = BSLK_DISPL_B;
                break;
            case 'c':
                ldata = BSLK_DISPL_C;
                break;
            case 'd':
                ldata = BSLK_DISPL_D;
                break;
            case 'e':
                ldata = BSLK_DISPL_E;
                break;
            case 'f':
                ldata = BSLK_DISPL_F;
                break;
            default:
                ldata = BSLK_DISPL_P;
                break;
        };
        switch (dbuf[1]) {
            case '0':
                mdata = BSLK_DISPM_0;
                break;
            case '1':
                mdata = BSLK_DISPM_1;
                break;
            case '2':
                mdata = BSLK_DISPM_2;
                break;
            case '3':
                mdata = BSLK_DISPM_3;
                break;
            case '4':
                mdata = BSLK_DISPM_4;
                break;
            case '5':
                mdata = BSLK_DISPM_5;
                break;
            case '6':
                mdata = BSLK_DISPM_6;
                break;
            case '7':
                mdata = BSLK_DISPM_7;
                break;
            case '8':
                mdata = BSLK_DISPM_8;
                break;
            case '9':
                mdata = BSLK_DISPM_9;
                break;
            case 'a':
                mdata = BSLK_DISPM_A;
                break;
            case 'b':
                mdata = BSLK_DISPM_B;
                break;
            case 'c':
                mdata = BSLK_DISPM_C;
                break;
            case 'd':
                mdata = BSLK_DISPM_D;
                break;
            case 'e':
                mdata = BSLK_DISPM_E;
                break;
            case 'f':
                mdata = BSLK_DISPM_F;
                break;
            default:
                mdata = BSLK_DISPM_P;
                break;
        };

        display_write(disp, mdata|ldata);
    }
}


void eeprom_test(eeprom* prom) {
    eeprom_select(prom);
    _eeprom_set_idle_condition(prom);

    uint8_t i;
    size_t n = 10;
    for(i = 0; i < n; i++)
        eeprom_write8(prom, 0x0010 + i, n-i-1);

    uint8_t buff;
    for(i = 0; i < n; i++) {
        eeprom_read8(prom, 0x0010 + i, &buff);
        printf("0x%.4x : 0x%.2x\n", 0x0010 + i, buff);
    }
}


void full_test(eeprom* prom, display* disp) {
    // generate random starting address that's no greater than 0x0FFF
    uint32_t addr = get_rand_32() % 0x0FFF;

    // create array of to-be-generated bytes
    size_t n = 10;
    uint8_t bytes[n];

    // write `n` random values to eeprom sequentially.
    eeprom_select(prom);
    printf("        ADDR       BYTE\n");
    uint8_t i;
    for(i = 0; i < n; i++) {
        // generate random byte and save for later validation
        bytes[i] = get_rand_32() % 0xFF;
        // write byte to address (contiguously incremented)
        eeprom_write8(prom, addr + i, bytes[i]);
        // print update to serial
        printf("WRITE: 0x%.4x <--- 0x%.2x\n", addr+i, bytes[i]);
    }

    // read `n` values that were written to EEPROM starting at `addr`
    uint8_t byte;
    for(i = 0; i < n; i++) {
        eeprom_select(prom);
        eeprom_read8(prom, addr+i, &byte);
        if (byte == bytes[i])
            printf("READ : 0x%.4x ---> 0x%.2x     [CORRECT]\n", addr+i, byte);
        else
            printf("READ : 0x%.4x ---> 0x%.2x     [-ERROR-]\n", addr+i, byte);

        // display byte
        display_select(disp);
        display_hex(disp, byte);

        // sleep for 1s
        sleep_ms(1000);
    }
}
